grf {
    grfid: "de\01\01";
    name: string(STR_GRF_NAME);
    desc: string(STR_GRF_DESCRIPTION);
    version: 0;
    min_compatible_version: 0;
}

cargotable {
    PASS, COAL, MAIL, OIL_, LVST, GOOD, GRAI, WOOD, IORE, STEL, VALU
}

PRODUCTION_BASE = 16;
PRODUCTION_MIN  = 5;
PRODUCTION_MAX  = 255;
STOCKPILE_LIMIT = 1000;




/********************
 * Production Changes
 ********************/

/* Random
 * A couple of functions to get range and chance. Downside is that RANDOM_CALLS
 * needs to be manually tracked...
 *
 * I could really do with more random numbers, but this is a GRF not an
 * encryption algorithm. So hopefully it'll do? */

//
// NOTE: You must keep track of RANDOM_CALLS manually! It will need updated if
// you use more random functions in the monthly_prod_change callback chain.
//
RANDOM_CALLS      = 4;
BIT_LEN           = 32 / RANDOM_CALLS;  // extra_callback_info2 is 32 bits long
RAND_MAX_PLUS_ONE = bitmask(BIT_LEN);

/* initRandom()
 * Not sure if temporary storage is initialised to zero, so let's make sure */
switch(FEAT_INDUSTRIES, SELF, initRandom,
    STORE_TEMP(0, 0)
) { return; }

/* getRandomBits()
 * Convenience function to get random bits, so one does not need to remember to
 * bit shift extra_callback_info2. */
switch(FEAT_INDUSTRIES, SELF, getRandomBits, [
    STORE_TEMP(getbits(extra_callback_info2, LOAD_TEMP(0), BIT_LEN), 1),
    STORE_TEMP(LOAD_TEMP(0) + BIT_LEN, 0)
]) { return LOAD_TEMP(1); }

/* randomChance(n, d)
 * n - numerator
 * d - denominator
 * Returns 2 with a probability of n/d. */
switch(FEAT_INDUSTRIES, SELF, randomChance, n, d,
    getRandomBits() < (RAND_MAX_PLUS_ONE * n / d)
) { return; }

/* randomRange(min, max)
 * Returns a random number in the range [min, max - 1] */
switch(FEAT_INDUSTRIES, SELF, randomRange, min, max,
    getRandomBits() * (max - min) / RAND_MAX_PLUS_ONE + min
) { return; }

/* setProductionRate(), getProductionRate()
 * Convenience functions to get/set production rate. */
switch(FEAT_INDUSTRIES, SELF, setProductionRate, rate, 0) {
    return STORE_PERM(rate, 0);
}
switch(FEAT_INDUSTRIES, SELF, getProductionRate, 0) {
    return LOAD_PERM(0);
}

/* Industry Closure
 * If an industry has not produced anything in 60 consecutive months (5 years)
 * it is considered abandoned and has a chance of closing. */
ABANDONMENT_PERIOD = 60;    // months
CLOSURE_CHANCE     = 180;

switch(FEAT_INDUSTRIES, SELF, isAbandoned, [
    (last_month_production("STEL") == 0)
        ? STORE_PERM(LOAD_PERM(1) + 1, 1)
        : STORE_PERM(0, 1),
    LOAD_PERM(1) > ABANDONMENT_PERIOD
]) {
    1: randomChance(1, CLOSURE_CHANCE);
    0;
}

/* Production Changes */
switch(FEAT_INDUSTRIES, SELF, setProductionLevel, [
    // naively half the rate to get the level, for now anyway
    STORE_TEMP((getProductionRate() / 2) << 16, 0x100)
]) {
    return CB_RESULT_IND_PROD_SET_BY_0x100;
}

/* getProductionChange()
 * should give a change in the range 3-23%, just like the smooth economy option */
switch(FEAT_INDUSTRIES, SELF, getProductionChange,
    max(1, randomRange(10, 60) * getProductionRate() / 256)
) { return; }

/* getIncreaseChance()
 * Returns chance of production increase based on transported cargo. Should
 * closely mirror the values used in a smooth economy */
switch(FEAT_INDUSTRIES, SELF, getIncreaseChance,
    transported_last_month_pct("STEL")
) {
    0..60:   randomChance(1, 3);
    61..80:  randomChance(2, 3);
    81..100: randomChance(5, 6);
}

/* calcNewProduction() */
switch(FEAT_INDUSTRIES, SELF, calcNewProduction,
    min(PRODUCTION_MAX, max(PRODUCTION_MIN,
        getProductionChange() * (getIncreaseChance() ? 1 : -1) + getProductionRate()))
) { return; }

/* doProductionChange()
 * 25% chance of a change each month */
switch(FEAT_INDUSTRIES, SELF, doProductionChange,
    randomChance(1, 4)
) {
    1: [
        setProductionRate(calcNewProduction()),
        setProductionLevel()
    ];
    CB_RESULT_IND_PROD_NO_CHANGE;
}

/* changeProduction() */
switch(FEAT_INDUSTRIES, SELF, changeProduction, [
    initRandom(),
    isAbandoned()
]) {
    1: CB_RESULT_IND_PROD_CLOSE;
    doProductionChange();
}

// genExtraText()
// Debugging for now, should display useful information in future!
switch(FEAT_INDUSTRIES, SELF, genExtraText, [
    STORE_TEMP(getProductionRate(), 256),
    STORE_TEMP(production_level, 257),
    STORE_TEMP(LOAD_PERM(2), 258),
]) {
    return string(STR_INDUSTRY_EXTRA_TEXT);
}


/********************
 * Steel Mill
 ********************/

// Cargo acceptance
switch(FEAT_INDUSTRIES, SELF, isStockpileFull, 0) {
    return STOCKPILE_LIMIT > incoming_cargo_waiting("IORE");
}

// Cargo production
produce(produceCargo,
    [
        IORE: LOAD_TEMP(0);
    ],
    [
        STEL: LOAD_TEMP(0);
    ],
    0
)

/* evalProductionCycle()
 * A production cycle is 256 ticks long */
switch(FEAT_INDUSTRIES, SELF, evalProductionCycle,
    STORE_TEMP(min(getProductionRate(), incoming_cargo_waiting("IORE")), 0)
) {
    return produceCargo;
}

produce(noProduction, [], [])

/* initPermanentStorage()
 * Registers:
 *      0x00: Production Rate
 *      0x01: Months Abandoned */
switch(FEAT_INDUSTRIES, SELF, initPermanentStorage,
    STORE_PERM(PRODUCTION_BASE, 0)
) { return; }

item(FEAT_INDUSTRIES, steel_mill) {
    property {
        substitute: INDUSTRYTYPE_STEEL_MILL;
        override:   INDUSTRYTYPE_STEEL_MILL;
        cargo_types: [
            accept_cargo("IORE"),
            produce_cargo("STEL", 0),
        ];
    }
    graphics {
        extra_text_industry:   genExtraText;
        produce_256_ticks:     evalProductionCycle;
        produce_cargo_arrival: noProduction;
        monthly_prod_change:   changeProduction;
        random_prod_change:    CB_RESULT_IND_PROD_NO_CHANGE;
        stop_accept_cargo:     isStockpileFull;
        build_prod_change:     initPermanentStorage;
    }
}

// tile override
item(FEAT_INDUSTRYTILES, steel_mill_tile_1) {
    property {
        substitute: 52;
        override: 52;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
}

item(FEAT_INDUSTRYTILES, steel_mill_tile_2) {
    property {
        substitute: 53;
        override: 53;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
}

item(FEAT_INDUSTRYTILES, steel_mill_tile_3) {
    property {
        substitute: 54;
        override: 54;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
}

item(FEAT_INDUSTRYTILES, steel_mill_tile_4) {
    property {
        substitute: 55;
        override: 55;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
}

item(FEAT_INDUSTRYTILES, steel_mill_tile_5) {
    property {
        substitute: 56;
        override: 56;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
}

item(FEAT_INDUSTRYTILES, steel_mill_tile_6) {
    property {
        substitute: 57;
        override: 57;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
}

grf {
    grfid: "de\01\01";
    name: string(STR_GRF_NAME);
    desc: string(STR_GRF_DESCRIPTION);
    version: 0;
    min_compatible_version: 0;
}

cargotable {
    PASS, COAL, MAIL, OIL_, LVST, GOOD, GRAI, WOOD, IORE, STEL, VALU
}

PRODUCTION_BASE = 16;
PRODUCTION_MIN  = 5;
PRODUCTION_MAX  = 255;
STOCKPILE_LIMIT = 15000;

/********************
 * Utilities
 ********************/

/* maxSigned(a, b)
 * Convenience wrapper around CMP(). Returns maximum value of a and b. Remember
 * to use last_computed_result if you're using or expecting numbers lower than
 * -128, as this will return values truncated to 15 bits. */
switch(FEAT_INDUSTRIES, SELF, maxSigned, a, b,
    CMP(a, b)
) {
    CMP_LESS:    b;
    CMP_EQUAL:   a;
    CMP_GREATER: a;
}

/********************
 * Production Changes
 ********************/

/* Random
 * A couple of functions to get range and chance. Downside is that RANDOM_CALLS
 * needs to be manually tracked...
 *
 * I could really do with more random numbers, but this is a GRF not an
 * encryption algorithm. So hopefully it'll do? */

//
// NOTE: You must keep track of RANDOM_CALLS manually! It will need updated if
// you use more random functions in the monthly_prod_change callback chain.
//
RANDOM_CALLS      = 4;
BIT_LEN           = 32 / RANDOM_CALLS;  // extra_callback_info2 is 32 bits long
RAND_MAX_PLUS_ONE = bitmask(BIT_LEN);

/* initRandom()
 * Not sure if temporary storage is initialised to zero, so let's make sure */
switch(FEAT_INDUSTRIES, SELF, initRandom,
    STORE_TEMP(0, 0)
) { return; }

/* getRandomBits()
 * Convenience function to get random bits, so one does not need to remember to
 * bit shift extra_callback_info2. */
switch(FEAT_INDUSTRIES, SELF, getRandomBits, [
    STORE_TEMP(getbits(extra_callback_info2, LOAD_TEMP(0), BIT_LEN), 1),
    STORE_TEMP(LOAD_TEMP(0) + BIT_LEN, 0)
]) { return LOAD_TEMP(1); }

/* randomChance(n, d)
 * n - numerator
 * d - denominator
 * Returns 2 with a probability of n/d. */
switch(FEAT_INDUSTRIES, SELF, randomChance, n, d,
    getRandomBits() < (RAND_MAX_PLUS_ONE * n / d)
) { return; }

/* randomRange(min, max)
 * Returns a random number in the range [min, max - 1] */
switch(FEAT_INDUSTRIES, SELF, randomRange, min, max,
    getRandomBits() * (max - min) / RAND_MAX_PLUS_ONE + min
) { return; }

/* setProductionRate(), getProductionRate()
 * Convenience functions to get/set production rate. */
switch(FEAT_INDUSTRIES, SELF, setProductionRate, rate,
    min(PRODUCTION_MAX, max(PRODUCTION_MIN, STORE_PERM(rate, 0)))
){ return; }
switch(FEAT_INDUSTRIES, SELF, getProductionRate,
    LOAD_PERM(0)
) { return; }

/* Industry Closure
 * If an industry has not produced anything in 60 consecutive months (5 years)
 * it is considered abandoned and has a chance of closing. */
ABANDONMENT_PERIOD = 60;    // months
CLOSURE_CHANCE     = 180;

switch(FEAT_INDUSTRIES, SELF, isAbandoned, [
    (last_month_production("STEL") == 0)
        ? STORE_PERM(LOAD_PERM(1) + 1, 1)
        : STORE_PERM(0, 1),
    LOAD_PERM(1) > ABANDONMENT_PERIOD
]) {
    1: randomChance(1, CLOSURE_CHANCE);
    0;
}

/* Production Changes */
switch(FEAT_INDUSTRIES, SELF, setProductionLevel, [
    // naively half the rate to get the level, for now anyway
    STORE_TEMP((getProductionRate() / 2) << 16, 0x100)
]) {
    return CB_RESULT_IND_PROD_SET_BY_0x100;
}

/* getProductionChange()
 * should give a change in the range 3-23%, just like the smooth economy option */
switch(FEAT_INDUSTRIES, SELF, getProductionChange,
    max(1, randomRange(10, 60) * getProductionRate() / 256)
) { return; }

/* chanceToIncrease(percent)
 * Returns chance based on percent parameter. Should closely mirror the values
 * used in a smooth economy */
switch(FEAT_INDUSTRIES, SELF, chanceToIncrease, percent,
    percent
) {
    0..60:   randomChance(1, 3);
    61..80:  randomChance(2, 3);
    81..100: randomChance(5, 6);
}

/* Industries have 8 or 9 production cycles a month so we use (8.5 * 6) */
PROD_CYCLE_SIX_MONTHS = 51;

switch(FEAT_INDUSTRIES, SELF, updateProduction, [
    // calculate impact of stockpile level on production rate
    STORE_TEMP((incoming_cargo_waiting("IORE") / PROD_CYCLE_SIX_MONTHS) - getProductionRate(), 1),
    STORE_TEMP(LOAD_TEMP(1) * 100 / getProductionRate(), 2),
    (LOAD_TEMP(2) < 0) ? [
        maxSigned(-20, LOAD_TEMP(2)),
        STORE_TEMP(last_computed_result, 3),
    ] : [
        STORE_TEMP(min(20, LOAD_TEMP(2)), 3),
    ],

    // impact of transported cargo
    STORE_TEMP(getProductionChange() * (chanceToIncrease(transported_last_month_pct("STEL")) ? 1 : -1), 4),

    setProductionRate(
        getProductionRate()
            + LOAD_PERM(0) * LOAD_TEMP(3) / 100
            + LOAD_TEMP(4)),

    setProductionLevel()
]) { return; }

/* shouldProductionChange() */
PRODUCTION_CHANGE_PROB = 3;
switch(FEAT_INDUSTRIES, SELF, shouldProductionChange,
    randomChance(1, PRODUCTION_CHANGE_PROB)
        && (transported_last_month_pct("STEL") > 0)
) {
    1: updateProduction();
    CB_RESULT_IND_PROD_NO_CHANGE;
}

/* changeProduction() */
switch(FEAT_INDUSTRIES, SELF, changeProduction, [
    initRandom(),
    isAbandoned()
]) {
    1: CB_RESULT_IND_PROD_CLOSE;
    shouldProductionChange();
}

// genExtraText()
// Debugging for now, should display useful information in future!
switch(FEAT_INDUSTRIES, SELF, genExtraText, [
    STORE_TEMP(getProductionRate(), 256),
    STORE_TEMP(production_level, 257),

    STORE_TEMP(LOAD_PERM(52), 258),
    STORE_TEMP(LOAD_PERM(53), 259),
    STORE_TEMP(LOAD_PERM(54), 260),
    STORE_TEMP(LOAD_PERM(55), 261),
]) {
    return string(STR_INDUSTRY_EXTRA_TEXT);
}


/********************
 * Steel Mill
 ********************/

// Cargo acceptance
switch(FEAT_INDUSTRIES, SELF, isStockpileFull, 0) {
    return STOCKPILE_LIMIT > incoming_cargo_waiting("IORE");
}

// Cargo production
produce(produceCargo,
    [
        IORE: LOAD_TEMP(0);
    ],
    [
        STEL: LOAD_TEMP(0);
    ],
    0
)

/* evalProductionCycle()
 * A production cycle is 256 ticks long */
switch(FEAT_INDUSTRIES, SELF, evalProductionCycle,
    STORE_TEMP(min(getProductionRate(), incoming_cargo_waiting("IORE")), 0)
) {
    return produceCargo;
}

produce(noProduction, [], [])

/* initPermanentStorage()
 * Registers:
 *      0x00: Production Rate
 *      0x01: Months Abandoned */
switch(FEAT_INDUSTRIES, SELF, initPermanentStorage,
    STORE_PERM(PRODUCTION_BASE, 0)
) { return; }

item(FEAT_INDUSTRIES, steel_mill) {
    property {
        substitute: INDUSTRYTYPE_STEEL_MILL;
        override:   INDUSTRYTYPE_STEEL_MILL;
        cargo_types: [
            accept_cargo("IORE"),
            produce_cargo("STEL", 0),
        ];
    }
    graphics {
        extra_text_industry:   genExtraText;
        produce_256_ticks:     evalProductionCycle;
        produce_cargo_arrival: noProduction;
        monthly_prod_change:   changeProduction;
        random_prod_change:    CB_RESULT_IND_PROD_NO_CHANGE;
        stop_accept_cargo:     isStockpileFull;
        build_prod_change:     initPermanentStorage;
    }
}

// tile override
item(FEAT_INDUSTRYTILES, steel_mill_tile_1) {
    property {
        substitute: 52;
        override: 52;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
}

item(FEAT_INDUSTRYTILES, steel_mill_tile_2) {
    property {
        substitute: 53;
        override: 53;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
}

item(FEAT_INDUSTRYTILES, steel_mill_tile_3) {
    property {
        substitute: 54;
        override: 54;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
}

item(FEAT_INDUSTRYTILES, steel_mill_tile_4) {
    property {
        substitute: 55;
        override: 55;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
}

item(FEAT_INDUSTRYTILES, steel_mill_tile_5) {
    property {
        substitute: 56;
        override: 56;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
}

item(FEAT_INDUSTRYTILES, steel_mill_tile_6) {
    property {
        substitute: 57;
        override: 57;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
}

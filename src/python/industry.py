from dataclasses import dataclass, InitVar
from string import Template
from pathlib import Path
from typing import Optional
from functools import singledispatch

from cargotable import CargoTable as Cargo


# fmt: off
@dataclass(frozen=True)
class Industry:
    """
    Storage for basic data about each industry.

    Args:
        id (str): The industry identifier. Should be a string from the list of
            default industries. See:
            https://newgrf-specs.tt-wiki.net/wiki/NML:Default_industries
        input(str|list[str]): Cargo accepted by the industry.
        output(str): Cargo generated by the industry.
        tiles (list[int], optional): Industry tile IDs to override. Only
            required if you change accepted cargo from the default. A list of
            industry tile IDs can be found here:
            https://newgrf-specs.tt-wiki.net/wiki/NML:Default_industry_tiles
        ratio (list[int], optional): Ratio of inputs consumed to output
            generated. e.g. A ratio of [2, 1, 2] consumes 2 units of input_0 and
            1 unit of input_1 to produce 2 units of output.
    """

    id:     str
    input:  InitVar[str | list[str]]
    output: str | None
    tiles:  Optional[list[int]] = None
    ratio:  Optional[list[int]] = None

    def __post_init__(self, input):
        if type(input) == list:
            object.__setattr__(self, "input", input)
        else:
            object.__setattr__(self, "input", [input])

        if self.ratio and len(self.ratio) != len(self.input) + 1:
            raise ValueError("Incorrect ratio length!")

    @property
    def name(self):
        return self.id[13:].lower()


# temperate industries
SECONDARY_INDUSTRIES = [
    Industry(
        "INDUSTRYTYPE_STEEL_MILL",
        [
            Cargo.IronOre,
            Cargo.Coal,
        ],
        Cargo.Steel,
        list(range(52, 58)),
        [2, 1, 2],
    ),
    Industry(
        "INDUSTRYTYPE_SAWMILL",
        Cargo.Wood,
        Cargo.Goods,
    ),
    Industry(
        "INDUSTRYTYPE_TEMPERATE_FACTORY",
        [
            Cargo.Livestock,
            Cargo.Grain,
            Cargo.Steel,
        ],
        Cargo.Goods,
    ),
    Industry(
        "INDUSTRYTYPE_OIL_REFINERY",
        Cargo.Oil,
        Cargo.Goods
    ),
]

TERTIARY_INDUSTRIES = [
    Industry(
        "INDUSTRYTYPE_POWER_PLANT",
        Cargo.Coal,
        None
    ),
]
# fmt: off


TEMPLATE_DIR = Path(__file__).parent / "templates"
def getTemplate(name):
    return Template((TEMPLATE_DIR / (name + ".txt")).read_text())


def generateIndustryPnml():
    pnml = ""

    secondary_template = getTemplate("secondary")
    tertiary_template = getTemplate("tertiary")

    for industry in SECONDARY_INDUSTRIES:
        pnml += secondary_template.substitute(getTemplateMapping(industry))
        pnml += genIndustryTiles(industry)

    for industry in TERTIARY_INDUSTRIES:
        pnml += tertiary_template.substitute(getTemplateMapping(industry))
        pnml += genIndustryTiles(industry)

    return pnml

# fmt: off
def getTemplateMapping(industry):
    return {
        "name":            industry.name,
        "produceblock":    genProduceBlock(industry),
        "stockpile_level": genRelevantLevel(industry),
        "input_output":    genInputOutput(industry),
        "power_limit":     genInputOutputPowerLimit(industry),
        "output":          industry.output,
        "id":              industry.id,
        "cargo_types":     genCargoTypes(industry),
        "fuel_consumed":   genFuelConsumed(industry),
    }
# fmt: on


@singledispatch
def indent(lines, indent_level, start=1):
    for idx, line in enumerate(lines[start:], start=start):
        lines[idx] = "    " * indent_level + line
    return "\n".join(lines)


@indent.register
def _(text: str, indent_level, start=1):
    lines = text.splitlines()
    return indent(lines, indent_level, start)


def genProduceBlock(industry):
    consume = []
    for reg_idx, input in enumerate(industry.input):
        consume.append(f"{input}: GET_TEMP(CONSUME_{reg_idx});")
    consume = "\n" + indent(consume, 1, start=0) + "\n"

    if industry.output:
        produce = f"\n    {industry.output}: GET_TEMP(PRODUCE);\n"
    else:
        produce = ""

    block = f"[{consume}], [{produce}]"

    return indent(block, 1)


def genInputOutput(industry):
    if industry.ratio:
        return genInputOutputRatio(industry)
    else:
        return genInputOutputStandard(industry)


def genInputOutputStandard(industry):
    consume_str = (
        "SET_TEMP("
            "CONSUME_{idx}, "
            'min(incoming_cargo_waiting("{input}"), GET_PERM(PRODUCTION_RATE))'
        "),"
    )
    consume_limits = []
    for idx, input in enumerate(industry.input):
        consume_limits.append(consume_str.format(idx=idx, input=input))

    produce_str = genProduceStringStandard(industry)
    return indent(consume_limits + [produce_str], 1)


def genProduceStringStandard(industry):
    produce_str = "SET_TEMP(PRODUCE, "
    for idx in range(len(industry.input)):
        produce_str += f"GET_TEMP(CONSUME_{idx}) + "
    return produce_str[:-3] + "),"


CONSUME_STR_RATIO = (
    "SET_TEMP("
        "CONSUME_{idx}, "
        "GET_TEMP(PRODUCE){ratio}"
    "),"
)

def genInputOutputRatio(industry):
    produce_str = "SET_TEMP(PRODUCE, min(GET_PERM(PRODUCTION_RATE), min("
    proportion_out = industry.ratio[-1]
    consume_limits = []
    for idx, input in enumerate(industry.input):
        produce_str += (
            f'incoming_cargo_waiting("{input}")'
            f"{getRatioString(proportion_out, industry.ratio[idx])}, "
        )
        consume_limits.append(
            CONSUME_STR_RATIO.format(
                idx=idx,
                input=input,
                ratio=getRatioString(industry.ratio[idx], proportion_out)
            )
        )
    produce_str = produce_str[:-2] + "))),"
    return indent([produce_str] + consume_limits, 1)


def getRatioString(numerator, denominator):
    ratio_str = ""
    if numerator != denominator:
        if numerator != 1:
            ratio_str += f" * {numerator}"
        if denominator != 1:
            ratio_str += f" / {denominator}"
    return ratio_str


def genInputOutputPowerLimit(industry):
    if industry.ratio:
        produce_str = genRegisterPowerLimit("PRODUCE")
        consume_str = CONSUME_STR_RATIO
    else:
        produce_str = genProduceStringStandard(industry)
        consume_str = genRegisterPowerLimit("CONSUME_{idx}")

    consume_limits = []
    for idx, input in enumerate(industry.input):
        values = {"idx": idx}
        if industry.ratio:
            values["ratio"] = getRatioString(industry.ratio[idx], industry.ratio[-1])
        consume_limits.append(consume_str.format(**values))

    if industry.ratio:
        power_limit = [produce_str] + consume_limits
    else:
        power_limit = consume_limits + [produce_str]

    return indent(power_limit, 2)


def genRegisterPowerLimit(register):
    return (
        f"SET_TEMP({register}, "
            f"GET_TEMP({register}) * getPowerSuppliedPct() / 100"
        "),"
    )


def genFuelConsumed(industry):
    return (
        "SET_TEMP(CONSUME_0, "
            'min(incoming_cargo_waiting("COAL"), '
                "min(GET_TEMP(FUEL_REQUIRED), PRODUCTION_MAX)"
            ")"
        "),"
    )


def genRelevantLevel(ind):
    relevant_level = f'incoming_cargo_waiting("{ind.input[0]}")'
    for input in ind.input[1:]:
        relevant_level = (
            f'max(incoming_cargo_waiting("{input}"), ' + relevant_level + ")"
        )
    return relevant_level


def genCargoTypes(industry):
    accept_cargo = []
    for input in industry.input:
        accept_cargo.append(f'accept_cargo("{input}"),')
    accept_cargo = indent(accept_cargo, 3)

    produce_cargo = ""
    if industry.output:
        produce_cargo = indent(f'\nproduce_cargo("{industry.output}", 0),', 3)

    return accept_cargo + produce_cargo


def genIndustryTiles(industry):
    if not industry.tiles:
        return ""

    tile_items = ""
    tile_template = getTemplate("industry_tile")
    for idx, tile_id in enumerate(industry.tiles):
        tile_items += tile_template.substitute(
            name=industry.name, idx=idx, tile_id=tile_id
        )

    return tile_items


def main(argv):
    print(generateIndustryPnml())


if __name__ == "__main__":
    import sys
    sys.exit(main(sys.argv))

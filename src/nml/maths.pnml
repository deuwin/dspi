#ifndef MATHS_PNML
#define MATHS_PNML

/********************
 * Maths
 ********************/

/* clamp(value, lower_limit, upper_limit) */
#define clamp(value, lower_limit, upper_limit) \
    min(upper_limit, max(lower_limit, value))


/* For an in-depth discussion on integer rounding implementation see:
 * https://blog.pkh.me/p/36-figuring-out-round%2C-floor-and-ceil-with-integer-division.html
 */

/* divideCeil(dividend, divisor)
 * Signed integer division with ceiling function applied to result
 */
switch(FEAT_INDUSTRIES, SELF, _divideCeil,
    dividend,
    divisor,
[
    dividend / divisor
        + (dividend % divisor != 0 && (((dividend ^ divisor) >> 31) == 0))
]) { return; }
#define divideCeil(dividend, divisor) \
    ((_divideCeil(dividend, divisor) & 0x0) + last_computed_result)


/* For the sake of completeness I'll note that for positive numbers standard
 * integer division is the same as a flooring function. */


/* divideRoundUInt(dividend, divisor)
 * Integer division with rounding. NOTE: Only for positive parameters!
 */
#define divideRoundUInt(dividend, divisor) \
    (((dividend) + ((divisor) / 2)) / (divisor))


/* divideRoundInt(dividend, divisor)
 * Signed integer division with rounding.
 */
#define divideRoundInt(dividend, divisor) \
    (((dividend ^ divisor) < 0) \
        ? ((dividend - (divisor / 2)) / divisor) \
        : ((dividend + (divisor / 2)) / divisor))

#endif // MATHS_PNML

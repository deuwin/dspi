/********************
 * Extra Text
 ********************/

// NOTE: The REPEAT() define used in this file is a bit of macro abuse to avoid
// tedious typing. Probably could've generated it with Python but this is kinda
// fun. See repeat.pnml for implementation.

/* Functions for temporary string parameter assignment and retrieval. These are
 * required as NML does not allow you to load values from addresses >255.
 */

// number of available dwords for string parameters
#define DWORD_NUMBER 6

/* getTempParam(idx)
 */
#define CASE_GET_TEMP_STR_PARAM(idx, _) \
    idx: LOAD_TEMP(TEMP_STR_PARAM + idx);
switch(FEAT_INDUSTRIES, SELF, getTempParam, idx, [
    idx
]) {
    REPEAT(DWORD_NUMBER, CASE_GET_TEMP_STR_PARAM, ~)
    CB_FAILED;
}

/* setTempParam(low_bits, high_bits)
 * Automatically increments the idx of the temporary stack "array". Should
 * hopefully help to avoid any indexing errors.
 */
#define CASE_SET_TEMP_STR_PARAM(idx, _)          \
    idx: STORE_TEMP(                             \
        (low_bits & 0xFFFF) | (high_bits << 16), \
        TEMP_STR_PARAM + idx                     \
    );

switch(FEAT_INDUSTRIES, SELF, setTempParam, low_bits, high_bits, [
    // store increment for next call, but return unmodified for current call
    INC_TEMP(STR_PARAM_IDX) - 1
]) {
    REPEAT(DWORD_NUMBER, CASE_SET_TEMP_STR_PARAM, ~)
    CB_FAILED;
}

/* setTempParamHigh(high_bits)
 */
switch(FEAT_INDUSTRIES, SELF, setTempParamHigh, high_bits, [
    DEC_TEMP(STR_PARAM_IDX),
    setTempParam(getTempParam(GET_TEMP(STR_PARAM_IDX)), high_bits)
]) { return; }

// set real string params
#define STORE_STRING_PARAM(idx, _)       \
    STORE_TEMP(                          \
        LOAD_TEMP(TEMP_STR_PARAM + idx), \
        256 + idx                        \
    ),
#define SET_STRING_PARAMETERS REPEAT(DWORD_NUMBER, STORE_STRING_PARAM, ~)


//
// Industry Power Status
//
switch(FEAT_INDUSTRIES, SELF, setPowerAvailableString, power_pct, [
    power_pct
]) {
    0:       SET_TEMP(POWER_STATUS, string(STR_POWER_STATUS_NONE));
    1..99:   SET_TEMP(POWER_STATUS, string(STR_POWER_STATUS_LOW));
    default: SET_TEMP(POWER_STATUS, string(STR_EMPTY));
}

switch(FEAT_INDUSTRIES, SELF, setPowerStatus, power_pct, [
    // WARN: You can't use industry_town_count() directly here. It must be
    // stored and retrieved. Probably something to do with how using it trashes
    // the contents of temporary storage registers 0x100 and 0x101.
    SET_TEMP(IND_COUNT, industry_town_count(power_plant)),
    (GET_TEMP(IND_COUNT) == 0) ? [
        SET_TEMP(POWER_PCT, 0),
        SET_TEMP(POWER_STATUS, string(STR_POWER_STATUS_NO_POWER_STATION))
    ]:[
        setPowerAvailableString(power_pct)
    ],
]) { return; }


//
// Production Strings
//
/* setProductionCapacity() */
switch(FEAT_INDUSTRIES, SELF, setProductionCapacity, [
    (power_required == 1) ? [
        SET_TEMP(POWER_PCT, getPowerSuppliedPct()),
        setPowerStatus(GET_TEMP(POWER_PCT))
    ]:[
        SET_TEMP(POWER_PCT, 100),
        SET_TEMP(POWER_STATUS, string(STR_EMPTY)),
    ],
    setTempParam(
        GET_TEMP(POWER_STATUS),
        GET_PERM(PRODUCTION_RATE) * GET_TEMP(POWER_PCT) / PRODUCTION_MAX)
]) { return; }

/* setProductionBreakdown(word_offset)
 * If word_offset is 1, begin writing in the high bytes of the previous param
 */
switch(FEAT_INDUSTRIES, SELF, setProductionBreakdown, word_offset, [
    (show_prod_breakdown == 1) ? [
        (!word_offset) ? [
            setTempParam(
                string(STR_PROD_BREAKDOWN),
                GET_PERM(IMPACT_STOCKPILE) * 100 / GET_PERM(PRODUCTION_RATE_PREV)
            ),
            setTempParam(
                GET_PERM(IMPACT_TRANSPORTED) * 100 / GET_PERM(PRODUCTION_RATE_PREV),
                0
            )
        ]:[
            setTempParamHigh(
                string(STR_PROD_BREAKDOWN)
            ),
            setTempParam(
                GET_PERM(IMPACT_STOCKPILE) * 100 / GET_PERM(PRODUCTION_RATE_PREV),
                GET_PERM(IMPACT_TRANSPORTED) * 100 / GET_PERM(PRODUCTION_RATE_PREV)
            ),
        ]
    ]:[0]
]) { return; }


//
// Stockpile String
//
#define STOCKPILE_PCT(value) (value * 100 / STOCKPILE_LIMIT)

switch(FEAT_INDUSTRIES, SELF, _setStockpileString,
    cargo_name,
    average,
    required,
    word_offset,
[
    (word_offset) ? [
        setTempParamHigh(cargo_name),
        setTempParam(STOCKPILE_PCT(average), STOCKPILE_PCT(required)),
    ]:[
        setTempParam(cargo_name, STOCKPILE_PCT(average)),
        setTempParam(STOCKPILE_PCT(required), 0),
    ]
]) { return; }

switch(FEAT_INDUSTRIES, SELF, setStockpileStringRatio,
    cargo_name,
    average,
    required,
    word_offset,
[
    _setStockpileString(cargo_name, average, required, word_offset)
]) { return; }

switch(FEAT_INDUSTRIES, SELF, setStockpileString,
    cargo_name,
    average,
    word_offset,
[
    _setStockpileString(cargo_name, average, STOCKPILE_REQUIRED, word_offset)
]) { return; }


//
// Extra Text
//
switch(FEAT_INDUSTRIES, SELF, genExtraText, cargo_name, [
    setProductionCapacity(),

    setStockpileString(
        cargo_name,
        getStockpileAverage(0),
        0),

    setProductionBreakdown(1),

    SET_STRING_PARAMETERS
]) {
    return string(STR_INDUSTRY_EXTRA_TEXT);
}

switch(FEAT_INDUSTRIES, SELF, temperate_factory_genExtraText, [
    setProductionCapacity(),

    setStockpileString(
        TTD_STR_CARGO_PLURAL_LIVESTOCK,
        getStockpileAverage(0),
        0),
    setStockpileString(
        TTD_STR_CARGO_PLURAL_GRAIN,
        getStockpileAverage(1),
        1),
    setStockpileString(
        TTD_STR_CARGO_PLURAL_STEEL,
        getStockpileAverage(2),
        0),

    setProductionBreakdown(1),
    SET_STRING_PARAMETERS
]) {
    return string(STR_INDUSTRY_EXTRA_TEXT_FACTORY);
}

switch(FEAT_INDUSTRIES, SELF, getGridStatus, [
    getPowerSuppliedPct()
]) {
    0:       SET_TEMP(GRID_STATUS, string(STR_GRID_NO_POWER));
    1..99:   SET_TEMP(GRID_STATUS, string(STR_GRID_OVERLOADED));
    default: SET_TEMP(GRID_STATUS, string(STR_GRID_HEALTHY));
}

switch(FEAT_INDUSTRIES, SELF, power_plant_genExtraText, [
    (hasPowerDemand())
        ? getGridStatus()
        : SET_TEMP(GRID_STATUS, string(STR_GRID_NO_DEMAND)),

    SET_TEMP(CAPACITY_PCT, GET_PERM(BURN_RATE) * 100 / BURN_RATE_MAX),

    // display a minimum of 1% production capacity if it would be rounded down
    // to zero
    (GET_TEMP(CAPACITY_PCT) == 0 && GET_PERM(BURN_RATE) != 0)
        ? SET_TEMP(CAPACITY_PCT, 1)
        : 0,

    setTempParam(
        GET_TEMP(CAPACITY_PCT),
        GET_TEMP(GRID_STATUS)),
    setTempParam(
        TTD_STR_CARGO_PLURAL_COAL,
        GET_PERM(STOCKPILE_AVERAGE_0)),
    setTempParam(
        TTD_STR_CARGO_PLURAL_OIL,
        GET_PERM(STOCKPILE_AVERAGE_1)),
    SET_STRING_PARAMETERS
]) {
    return string(STR_INDUSTRY_EXTRA_TEXT_POWER_PLANT);
}
